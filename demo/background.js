let tabURLs;        // a Map that holds the URL of the page on each open tab, indexed by tabId's generated by chrome.
let urlTitles;      // a Map that holds the title of every URL visited.
let sessionGraph;   // a Map that holds all nodes in the session, indexed by their URL's.


chrome.runtime.onInstalled.addListener(function () { // runs when the extension is installed or updated
    initialize();
    addListeners();

    // initializes the data structures of this background page.
    function initialize() {
        tabURLs = new Map();
        urlTitles = new Map();
        sessionGraph = new Map();
    }

    // adds the listeners to relevant chrome events.
    function addListeners() {
        chrome.tabs.onUpdated.addListener(tabUpdated);
        chrome.tabs.onRemoved.addListener(tabRemoved);        
    }
});

/**
 * The event that fires when a tab is updated.
 * @param {number} tabId        The unique tabId generated by chrome. This is the id used to index tabURLs.
 * @param {object} changeInfo   Changes to the state of the tab. Check https://developer.chrome.com/docs/extensions/reference/tabs/ for info.
 * @param {Tab} tab             The chrome tab object, more info in the link above.
 */
function tabUpdated(tabId, changeInfo, tab) {

    if (changeInfo.url && !changeInfo.url.startsWith("chrome")) { // do not consider the pages that start with chrome, no history is kept for them.
        urlLoaded(tabId, tab.url);
    }
    else if(changeInfo.title) {
        if(sessionGraph.get(tab.url))
            setTimeout( () => {sessionGraph.get(tab.url).title = changeInfo.title}, 30);
        /*
         * ChangeInfo contains a title on two different triggers: when the URL changes and when the page's actual title loads.
         * by doing this in the "else", we guarantee that we will get the actual title and not the URL.
         * We wait a bit before doing this to make sure the sesisonGraph actually contains the node.
         */
    }
}

function tabRemoved( tabId, removeInfo) {
    // the page isn't open in that tab anymore
    let node = sessionGraph.get(tabURLs.get(tabId));
    if(node)
        node.openTabCount--;

    tabURLs.delete(tabId);
}

/**
 * The event that fires when a new page is loaded in any tab
 * @param {number} tabId    The id of the tab that contains the new page.
 * @param {string} url      The URL of the page.
 */
async function urlLoaded(tabId, url) {
    let node = sessionGraph.get(url);

    if (node) {
        // the url was opened before, there is a node in the graph with this url.
        // ? If we're going to keep track of all visits (ditch the session tree), the link needs to be added here.
        
        //update the open tab count
        node.openTabCount++;
        
    } else {
        node = new SessionNode(url, "no titles yet", 1);
        sessionGraph.set(url, node); // add the node to the graph

        chrome.tabs.get(tabId , function(tab){
            node.title = tab.title; // this is asyncronous but that should be ok.
        });

        if ( await lastVisitIsEdge(url)) {
            let sourceNode =  await findActiveNode();
            if(sourceNode) {
                // add the new node as a child.
                sourceNode.children.push(node);
            } else {
                console.warn( "The parent of the newly loaded page is not in the session graph.");
            }
        }
    }

    // the tab does not contain the old page anymore.
    let oldURL = tabURLs.get(tabId);
    if(oldURL)
        sessionGraph.get(oldURL).openTabCount --;
    
    // update the URL open in the tab.
    tabURLs.set(tabId, url);

    return null;
    //--------------------------- helper functions --------------------------------
    /**
     * @returns {SessionNode} The node open in the active tab.
     */
    async function findActiveNode() {
        return new Promise ( function (resolve, reject) {
            // request the active tab. 
            chrome.tabs.query({ active: true, currentWindow: true }, function (tabs) {
                // find the corresponding node.
                let URL = tabURLs.get(tabs[0].id);
                sourceNode = sessionGraph.get(URL);
                resolve (sourceNode);
            });
        });
    }

    async function lastVisitIsEdge(url) {
        return new Promise( function (resolve, reject) {
            // request a list of visits to the url.
            chrome.history.getVisits({ url: url }, function (visitItems) {
                console.log("The page was visited ", visitItems.length, " times.");
                console.log("Last transition type is ", visitItems[visitItems.length - 1].transition);
                // if the new url is last visited by a link, the new page's node is a child of the node this tab is at.
                if (visitItems[visitItems.length - 1].transition == "link" ||
                    visitItems[visitItems.length - 1].transition == "form_submit") {
                    resolve(true);
                } else resolve(false);
            });
        }); 
    }

}

// chrome.runtime.onInstalled.addListener(function () {
//     chrome.storage.local.set({ sessionGraph: [] });

//     chrome.tabs.onUpdated.addListener(function (tabId, changeInfo, tab) {
//         console.log(tab.title);

//         if(!changeInfo.url) {
//             urlTitles.set(tab.url, tab.title); // bunlar önce firelarsa ok

//             chrome.storage.local.get("sessionGraph", function (res) {
//                 let sessionGraph = res.sessionGraph;
//                 let node = search(sessionGraph, tab.url);
//                 if(node != null) {
//                     node.title = tab.title;
//                     chrome.storage.local.set({ sessionGraph: sessionGraph });
//                     console.log("az daha sıçıyoduk");
//                 }
//             });
//         }

//         if (changeInfo.url && changeInfo.url != "chrome://newtab/") {
//             console.log(changeInfo.url);
//             // a tab switched to a new URL

//             chrome.storage.local.get("sessionGraph", function (res) {
//                 let sessionGraph = res.sessionGraph;
//                 console.log(sessionGraph);

//                 // if the url is already in the graph, how the page is visited does not matter.
//                 //  we don't create a new node and only change the tab.
//                 let newNode = search(sessionGraph, changeInfo.url);
//                 if (newNode) {
//                     console.log("This url already is in the graph");
//                     let oldNode = search(sessionGraph, tabURLs.get(tabId));
//                     if(oldNode != null)
//                         oldNode.openTabCount --;

//                     newNode.openTabCount ++;

//                     chrome.storage.local.set({ sessionGraph: sessionGraph });
//                     tabURLs.set(tabId, tab.url); 
//                 } else {
//                     // determine how the page was visited.
//                     chrome.history.getVisits({ url: tab.url }, function (visitItems) {
//                         console.log("The page was visited ", visitItems.length, " times.");
//                         console.log("Last transition type is ", visitItems[visitItems.length - 1].transition);
//                         // if the new url is last visited by a link, the new page's node is a child of the node this tab is at.
//                         if (visitItems[visitItems.length - 1].transition == "link" ||
//                             visitItems[visitItems.length - 1].transition == "form_submit") {
//                             let parentURL = tabURLs.get(tabId);
//                             console.log("Adding ", tab.url, " with parent: ", parentURL);

//                             // make a recursive search to find the parent.
//                             let parentNode = search(sessionGraph, parentURL);

//                             if(parentNode != null) {
//                                 console.log("found the parent!")
//                                 parentNode.children.push(new SessionNode(changeInfo.url, urlTitles.get(changeInfo.url), 1));
//                                 console.log(tab.title);
//                                 parentNode.openTabCount--;
//                             } else {
//                                 // add the page as a root.
//                                 console.log("Adding ", tab.url, " as a root.");
//                                 sessionGraph.push(new SessionNode(changeInfo.url, urlTitles.get(changeInfo.url),1));
//                             }
//                         } else {
//                             let oldNode = search(sessionGraph, tabURLs.get(tabId));
//                             if(oldNode)
//                                 oldNode.openTabCount ++;
//                             // add the page as a root.
//                             console.log("Adding ", tab.url, " as a root.");
//                             sessionGraph.push(new SessionNode(changeInfo.url, urlTitles.get(changeInfo.url),1));
//                         }
//                         chrome.storage.local.set({ sessionGraph: sessionGraph });
//                         tabURLs.set(tabId, tab.url);
//                     });
//                 }
//             });
//         }
//     });
//     function search(sessionGraph, url) {
//         for (let i = 0; i < sessionGraph.length; i++) {
//             let res = search_helper(url, sessionGraph[i]);
//             if (res != undefined)
//                 return res;
//         }
//         return null;

//         function search_helper(url, node) {
//             if (node.url == url)
//                 return node;
//             else {
//                 for (child in node.children) {
//                     result = search_helper(url, node.children[child]);
//                     if (result != null)
//                         return result;
//                 }
//             }
//         }
//     }

//     chrome.tabs.onRemoved.addListener( function( tabId, removeInfo) {
//         chrome.storage.local.get("sessionGraph", function (res) {
//             let sessionGraph = res.sessionGraph;
//             let node = search(sessionGraph, tabURLs.get(tabId));
//             if(node){
//                 node.openTabCount --;
//                 chrome.storage.local.set({ sessionGraph: sessionGraph });
//             }
//         });
//     });
// });

function getSessionGraph() {return sessionGraph};

class SessionNode {
    /**
     * @param {String} url 
     */
    constructor(url, title, openTabCount) {
        this.openTabCount = openTabCount;
        this.title = title;
        this.url = url;
        this.children = [];
    }
} 